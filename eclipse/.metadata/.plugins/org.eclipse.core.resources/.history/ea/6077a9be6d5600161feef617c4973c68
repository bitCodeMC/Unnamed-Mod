package com.bitCode.test.blocks;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import com.bitCode.test.IFeeder;
import com.bitCode.test.util.BlockCoord;
import com.google.common.base.Predicate;
import net.minecraft.block.Block;
import net.minecraft.block.material.MapColor;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

public class Feeder extends Block {
	 private int changeCount;
	 private final Map<Integer, Map<BlockCoord, IFeeder>> perWorldChargers = new HashMap<Integer, Map<BlockCoord, IFeeder>>();
	 static {    
		    MinecraftForge.EVENT_BUS.register(Feeder.instance);
		  }
	 public static Feeder instance = new Feeder(Material.ROCK);
	  public static final int RANGE = 5;
	  public static final int RANGE_SQ = RANGE * RANGE;
	 @SubscribeEvent
	  public void onPlayerTick(TickEvent.PlayerTickEvent event)
	  {
		 EntityPlayer player=event.player;
		 BlockPos pos = player.getPosition();
		 
	  }
	public Feeder(Material materialIn) {
		super(materialIn);
		// TODO Auto-generated constructor stub
	}

	public Feeder(Material blockMaterialIn, MapColor blockMapColorIn) {
		super(blockMaterialIn, blockMapColorIn);
		// TODO Auto-generated constructor stub
	}

	@Override
	public void updateTick(World worldIn, BlockPos pos, IBlockState state, Random rand) {
//.getPlayers(EntityPlayerMP.class, new Predicate<EntityPlayerMP>());
	}
	
	
	
	 public void registerFeeder(IFeeder feeder) {
	    if(feeder == null) {
	        return;
	      }
	      Map<BlockCoord, IFeeder> chargers = getChargersForWorld(feeder.getWorldObj());
	      chargers.put(feeder.getLocation(), feeder);
	      changeCount++;
	    }

	    public void deregisterCharger(IFeeder capBank) {
	      if(capBank == null) {
	        return;
	      }
	      Map<BlockCoord, IFeeder> chargers = getChargersForWorld(capBank.getWorldObj());
	      chargers.remove(capBank.getLocation());
	      changeCount++;
	    }
	    public int getChangeCount() {
	        return changeCount;
	      }
	    private Map<BlockCoord, IFeeder> getChargersForWorld(World world) {
	        Map<BlockCoord, IFeeder> res = perWorldChargers.get(world.provider.getDimension());
	        if(res == null) {
	          res = new HashMap<BlockCoord, IFeeder>();
	          perWorldChargers.put(world.provider.getDimension(), res);
	        }
	        return res;
	      }
	    
	    public void chargePlayersItems(EntityPlayer player) {
	        Map<BlockCoord, IFeeder> chargers = getChargersForWorld(player.worldObj);
	        if(chargers.isEmpty()) {
	          return;
	        }
	        BlockCoord bc = new BlockCoord(player);
	        for (IFeeder capBank : chargers.values()) {
	          if (capBank.isActive() && inRange(capBank.getLocation(), bc)) {
	            boolean done = chargeFromCapBank(player, capBank);
	            if(done) {
	              return;
	            }
	          }
	        }
	      }
	    private boolean chargeFromCapBank(EntityPlayer player, IFeeder capBank) {
	        boolean res = capBank.chargeItems(player.inventory.armorInventory);
	        res |= capBank.chargeItems(player.inventory.mainInventory);
	        res |= capBank.chargeItems(player.inventory.offHandInventory);
	       
	        return res;
	      }
	    private boolean inRange(BlockCoord a, BlockCoord b) {
	        // distSq can overflow int, so check for square coords first.
	        int dx = a.x - b.x;
	        if (dx > RANGE || dx < -RANGE) {
	          return false;
	        }
	        int dz = a.z - b.z;
	        if (dz > RANGE || dz < -RANGE) {
	          return false;
	        }
	        return a.getDistSq(b) <= RANGE_SQ;
	      }

}
